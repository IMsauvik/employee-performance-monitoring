import React, { useState, useEffect, useRef } from 'react';import { useState, useRef, useEffect } from 'react';

import { useAuth } from '../../context/AuthContext';import { 

import { storage } from '../../utils/storage';  X, Send, AlertTriangle, AtSign, User, Clock, Edit2, Trash2, 

import { useTaskDiscussion } from '../../hooks/useTaskDiscussion';  MessageCircle, Smile, ThumbsUp, Heart, Star, UserCheck, Wifi, WifiOff 

import { TypingIndicator } from './TypingIndicator';} from 'lucide-react';

import { Reactions } from './Reactions';import { useAuth } from '../../context/AuthContext';

import { LoadingSpinner } from './LoadingSpinner';import { useTaskComments } from '../../hooks/useTaskComments';

import { eventBus } from '../../utils/eventBus';import { storage } from '../../utils/storage';

import { import NotificationService from '../../services/notificationService';

  X, Send, AlertTriangle, AtSign, User, Clock, Edit2, Trash2, import { toast } from 'react-hot-toast';

  MessageCircle, Smile, ThumbsUp, Heart, Star, UserCheck, Wifi, WifiOff import { formatDistanceToNow } from 'date-fns';

} from 'lucide-react';

import NotificationService from '../../services/notificationService';const REACTION_EMOJIS = {

import { toast } from 'react-hot-toast';  like: { icon: ThumbsUp, label: 'Like' },

import { formatDistanceToNow } from 'date-fns';  love: { icon: Heart, label: 'Love' },

  star: { icon: Star, label: 'Star' }

const REACTION_EMOJIS = {};

  like: { icon: ThumbsUp, label: 'Like' },

  love: { icon: Heart, label: 'Love' },const TaskCommentsModal = ({ task, isOpen, onClose, onTaskUpdate }) => {

  star: { icon: Star, label: 'Star' }  const { currentUser } = useAuth();

};  const { 

    comments, 

export const TaskCommentsModal = ({ task, isOpen, onClose, onTaskUpdate }) => {    addComment, 

  const { currentUser } = useAuth();    deleteComment, 

  const [commentText, setCommentText] = useState('');    refreshComments,

  const [isBlocker, setIsBlocker] = useState(false);    typingUsers,

  const [blockerType, setBlockerType] = useState('dependency');    onlineUsers,

  const [showMentions, setShowMentions] = useState(false);    error,

  const [mentionSearch, setMentionSearch] = useState('');    setTyping,

  const [cursorPosition, setCursorPosition] = useState(0);    markAsRead,

  const [isOnline, setIsOnline] = useState(navigator.onLine);    toggleReaction,

  const [allUsers, setAllUsers] = useState([]);    getReadStatus,

  const textareaRef = useRef(null);    getReactions,

    isUserOnline

  const {  } = useTaskComments(task?.id);

    comments,

    loading,  const [commentText, setCommentText] = useState('');

    error,  const [isBlocker, setIsBlocker] = useState(false);

    typingUsers,  const [blockerType, setBlockerType] = useState('dependency');

    addComment,  const [showMentions, setShowMentions] = useState(false);

    updateComment,  const [mentionSearch, setMentionSearch] = useState('');

    deleteComment,  const [cursorPosition, setCursorPosition] = useState(0);

    setTyping,  const [showReactionPicker, setShowReactionPicker] = useState(null);

    refresh: refreshComments  const [isOnline, setIsOnline] = useState(navigator.onLine);

  } = useTaskDiscussion(task?.id);  const textareaRef = useRef(null);



  useEffect(() => {  const [allUsers, setAllUsers] = useState([]);

    if (isOpen) {

      const users = storage.getUsers();  useEffect(() => {

      setAllUsers(users);    if (isOpen) {

      refreshComments();      const users = storage.getUsers();

    }      setAllUsers(users);

  }, [isOpen, refreshComments]);      refreshComments();

      

  useEffect(() => {      // Show typing indicator or other real-time updates

    if (isOpen && textareaRef.current) {      const handleCommentUpdate = (data) => {

      textareaRef.current.focus();        switch (data.type) {

    }          case 'add':

  }, [isOpen]);            toast.success('New comment added');

            break;

  useEffect(() => {          case 'update':

    const handleOnline = () => setIsOnline(true);            toast.success('Comment updated');

    const handleOffline = () => setIsOnline(false);            break;

          case 'delete':

    window.addEventListener('online', handleOnline);            toast.success('Comment deleted');

    window.addEventListener('offline', handleOffline);            break;

        }

    return () => {      };

      window.removeEventListener('online', handleOnline);

      window.removeEventListener('offline', handleOffline);      // Subscribe to comment updates

    };      const unsubscribe = eventBus.subscribe(`taskComments:${task.id}`, handleCommentUpdate);

  }, []);

      return () => {

  if (!isOpen || !task) return null;        unsubscribe();

      };

  const extractMentions = (text) => {    }

    const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;  }, [isOpen, task?.id]);

    const mentions = [];

    let match;  if (!isOpen || !task) return null;

    while ((match = mentionRegex.exec(text)) !== null) {

      mentions.push(match[2]); // User ID  // Parse @mentions from text

    }  const extractMentions = (text) => {

    return mentions;    const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;

  };    const mentions = [];

    let match;

  const getMentionSuggestions = () => {    while ((match = mentionRegex.exec(text)) !== null) {

    if (!mentionSearch) return [];      mentions.push(match[2]); // User ID

    }

    const search = mentionSearch.toLowerCase();    return mentions;

    return allUsers  };

      .filter(u =>

        u.id !== currentUser.id &&  // Filter users for mention suggestions

        (u.name.toLowerCase().includes(search) || u.email.toLowerCase().includes(search))  const getMentionSuggestions = () => {

      )    if (!mentionSearch) return [];

      .slice(0, 5);

  };    const search = mentionSearch.toLowerCase();

    return allUsers

  const handleTextChange = (e) => {      .filter(u =>

    const text = e.target.value;        u.id !== currentUser.id &&

    const cursorPos = e.target.selectionStart;        (u.name.toLowerCase().includes(search) || u.email.toLowerCase().includes(search))

      )

    setCommentText(text);      .slice(0, 5);

    setCursorPosition(cursorPos);  };

    setTyping(currentUser.id, text.length > 0);

  // Handle @ key press

    // Handle @ mentions  const handleTextChange = (e) => {

    const beforeCursor = text.substring(0, cursorPos);    const text = e.target.value;

    const lastAtSign = beforeCursor.lastIndexOf('@');    const cursorPos = e.target.selectionStart;



    if (lastAtSign !== -1 && lastAtSign === cursorPos - 1) {    setCommentText(text);

      setShowMentions(true);    setCursorPosition(cursorPos);

      setMentionSearch('');

    } else if (lastAtSign !== -1 && cursorPos > lastAtSign) {    // Check if we just typed @

      const searchText = beforeCursor.substring(lastAtSign + 1);    const beforeCursor = text.substring(0, cursorPos);

      if (!searchText.includes(' ') && !searchText.includes('\n')) {    const lastAtSign = beforeCursor.lastIndexOf('@');

        setMentionSearch(searchText);

        setShowMentions(true);    if (lastAtSign !== -1 && lastAtSign === cursorPos - 1) {

      } else {      setShowMentions(true);

        setShowMentions(false);      setMentionSearch('');

      }    } else if (lastAtSign !== -1 && cursorPos > lastAtSign) {

    } else {      const searchText = beforeCursor.substring(lastAtSign + 1);

      setShowMentions(false);      if (!searchText.includes(' ') && !searchText.includes('\n')) {

    }        setMentionSearch(searchText);

  };        setShowMentions(true);

      } else {

  const insertMention = (user) => {        setShowMentions(false);

    const beforeCursor = commentText.substring(0, cursorPosition);      }

    const afterCursor = commentText.substring(cursorPosition);    } else {

    const lastAtSign = beforeCursor.lastIndexOf('@');      setShowMentions(false);

    }

    const newText =  };

      beforeCursor.substring(0, lastAtSign) +

      `@[${user.name}](${user.id}) ` +  // Insert mention

      afterCursor;  const insertMention = (user) => {

    const beforeCursor = commentText.substring(0, cursorPosition);

    setCommentText(newText);    const afterCursor = commentText.substring(cursorPosition);

    setShowMentions(false);    const lastAtSign = beforeCursor.lastIndexOf('@');

    setMentionSearch('');

    const newText =

    // Focus back on textarea      beforeCursor.substring(0, lastAtSign) +

    setTimeout(() => {      `@[${user.name}](${user.id}) ` +

      textareaRef.current?.focus();      afterCursor;

    }, 0);

  };    setCommentText(newText);

    setShowMentions(false);

  const handleSubmit = async () => {    setMentionSearch('');

    if (!commentText.trim()) return;

    // Focus back on textarea

    const mentions = extractMentions(commentText);    setTimeout(() => {

    const wasBlocker = isBlocker;      textareaRef.current?.focus();

    }, 0);

    try {  };

      const commentData = {

        text: commentText,  // Submit comment

        authorId: currentUser.id,  const handleSubmit = async () => {

        authorName: currentUser.name,    if (!commentText.trim()) return;

        authorRole: currentUser.role,

        type: wasBlocker ? 'blocker' : 'comment',    const mentions = extractMentions(commentText);

        mentions,    const wasBlocker = isBlocker; // Store blocker state before clearing

        metadata: wasBlocker ? {

          blockerType,    const commentData = {

          status: 'open'      text: commentText,

        } : {},      authorId: currentUser.id,

        notifyUserId: task.assignedBy      authorName: currentUser.name,

      };      authorRole: currentUser.role,

      type: wasBlocker ? 'blocker' : 'comment',

      // Clear form immediately for better UX      mentions,

      setCommentText('');      metadata: wasBlocker ? {

      setIsBlocker(false);        blockerType,

      setBlockerType('dependency');        status: 'open'

      setTyping(currentUser.id, false);      } : {},

      notifyUserId: task.assignedBy // Notify the manager who assigned the task

      // Add comment    };

      const newComment = await addComment(commentData);

    // Clear form immediately for better UX

      // Show success toast    setCommentText('');

      toast.success(wasBlocker ? 'Blocker reported successfully!' : 'Comment added successfully!');    setIsBlocker(false);

    setBlockerType('dependency');

      // If blocker, update task status

      if (wasBlocker && task.status !== 'blocked') {    // Add comment

        onTaskUpdate && onTaskUpdate(task.id, { status: 'blocked' });    const newComment = addComment(commentData);

      }

    // Show success toast

      // Handle notifications    if (wasBlocker) {

      const recipients = [];      toast.success('Blocker reported successfully!');

    } else {

      // Add mentioned users' emails      toast.success('Comment added successfully!');

      if (mentions.length > 0) {    }

        const mentionedUsers = allUsers.filter(u => mentions.includes(u.id));

        mentionedUsers.forEach(u => {    // If blocker, update task status

          if (u.email && u.id !== currentUser.id) {    if (wasBlocker && task.status !== 'blocked') {

            recipients.push(u.email);      onTaskUpdate && onTaskUpdate(task.id, { status: 'blocked' });

          }    }

        });

      }    // Send email notifications

    try {

      // Add task assignee and assigner      const recipients = [];

      const assignedUser = allUsers.find(u => u.id === task.assignedTo);

      const assignedByUser = allUsers.find(u => u.id === task.assignedBy);      // Add mentioned users' emails

      if (mentions.length > 0) {

      if (assignedUser && assignedUser.email && assignedUser.id !== currentUser.id && !recipients.includes(assignedUser.email)) {        const mentionedUsers = allUsers.filter(u => mentions.includes(u.id));

        recipients.push(assignedUser.email);        mentionedUsers.forEach(u => {

      }          if (u.email && u.id !== currentUser.id) {

      if (assignedByUser && assignedByUser.email && assignedByUser.id !== currentUser.id && !recipients.includes(assignedByUser.email)) {            recipients.push(u.email);

        recipients.push(assignedByUser.email);          }

      }        });

      }

      // Send notifications if there are recipients

      if (recipients.length > 0) {      // Add task assignee and assigner

        await NotificationService.sendCommentNotification(recipients, {      const assignedUser = allUsers.find(u => u.id === task.assignedTo);

          taskName: task.taskName,      const assignedByUser = allUsers.find(u => u.id === task.assignedBy);

          taskDescription: task.taskDescription,

          authorName: currentUser.name,      if (assignedUser && assignedUser.email && assignedUser.id !== currentUser.id && !recipients.includes(assignedUser.email)) {

          commentText: commentText,        recipients.push(assignedUser.email);

          isBlocker: wasBlocker,      }

          mentions,      if (assignedByUser && assignedByUser.email && assignedByUser.id !== currentUser.id && !recipients.includes(assignedByUser.email)) {

          taskUrl: `${window.location.origin}/tasks/${task.id}`        recipients.push(assignedByUser.email);

        });      }

      }

    } catch (error) {      // Send notifications if there are recipients

      console.error('Failed to add comment:', error);      if (recipients.length > 0) {

      toast.error('Failed to add comment. Please try again.');        await NotificationService.sendCommentNotification(recipients, {

    }          taskName: task.taskName,

  };          taskDescription: task.taskDescription,

          authorName: currentUser.name,

  const renderCommentText = (text) => {          commentText: commentText,

    const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;          isBlocker: isBlocker,

    const parts = [];          mentions: mentions,

    let lastIndex = 0;          taskUrl: `${window.location.origin}/manager/tasks` // Adjust based on user role

    let match;        });



    while ((match = mentionRegex.exec(text)) !== null) {        console.log(`Email notifications sent to ${recipients.length} recipient(s)`);

      // Add text before mention      }

      if (match.index > lastIndex) {    } catch (error) {

        parts.push(text.substring(lastIndex, match.index));      console.error('Failed to send email notifications:', error);

      }      // Don't block the comment submission if email fails

      // Add mention    }

      parts.push(  };

        <span key={match.index} className="bg-indigo-100 text-indigo-700 px-1 rounded font-medium">

          @{match[1]}  // Render comment with formatted mentions

        </span>  const renderCommentText = (text) => {

      );    const mentionRegex = /@\[([^\]]+)\]\(([^)]+)\)/g;

      lastIndex = match.index + match[0].length;    const parts = [];

    }    let lastIndex = 0;

    let match;

    // Add remaining text

    if (lastIndex < text.length) {    while ((match = mentionRegex.exec(text)) !== null) {

      parts.push(text.substring(lastIndex));      // Add text before mention

    }      if (match.index > lastIndex) {

        parts.push(text.substring(lastIndex, match.index));

    return parts.length > 0 ? parts : text;      }

  };      // Add mention

      parts.push(

  return (        <span key={match.index} className="bg-indigo-100 text-indigo-700 px-1 rounded font-medium">

    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">          @{match[1]}

      <div className="bg-white rounded-xl overflow-hidden max-w-2xl w-full max-h-[90vh] flex flex-col">        </span>

        {/* Header */}      );

        <div className="px-6 py-4 border-b border-gray-200 flex items-center justify-between">      lastIndex = match.index + match[0].length;

          <div className="flex items-center gap-4">    }

            <h3 className="text-lg font-semibold text-gray-900 flex items-center gap-2">

              <MessageCircle className="w-5 h-5" />    // Add remaining text

              Task Comments    if (lastIndex < text.length) {

            </h3>      parts.push(text.substring(lastIndex));

            {/* Online Status */}    }

            <div className="flex items-center gap-2 text-sm">

              {isOnline ? (    return parts.length > 0 ? parts : text;

                <div className="flex items-center text-green-600 gap-1">  };

                  <Wifi className="w-4 h-4" />

                  <span>Online</span>  const suggestions = showMentions ? getMentionSuggestions() : [];

                </div>

              ) : (  return (

                <div className="flex items-center text-red-600 gap-1">    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">

                  <WifiOff className="w-4 h-4" />      <div className="bg-white rounded-xl overflow-hidden max-w-2xl w-full">

                  <span>Offline</span>        {/* Header */}

                </div>        <div className="px-6 py-4 border-b border-gray-200 flex items-center justify-between">

              )}          <div className="flex items-center gap-4">

            </div>            <h3 className="text-lg font-semibold text-gray-900 flex items-center gap-2">

            {/* Error Message */}              <MessageCircle className="w-5 h-5" />

            {error && (              Task Comments

              <div className="text-red-600 text-sm flex items-center gap-1">            </h3>

                <AlertTriangle className="w-4 h-4" />            {/* Online Status Indicator */}

                <span>{error}</span>            <div className="flex items-center gap-2 text-sm">

              </div>              {isOnline ? (

            )}                <div className="flex items-center text-green-600 gap-1">

          </div>                  <Wifi className="w-4 h-4" />

          <button                  <span>Online</span>

            onClick={onClose}                </div>

            className="text-gray-400 hover:text-gray-500"              ) : (

          >                <div className="flex items-center text-red-600 gap-1">

            <X className="w-5 h-5" />                  <WifiOff className="w-4 h-4" />

          </button>                  <span>Offline</span>

        </div>                </div>

              )}

        {/* Comments List */}            </div>

        <div className="flex-1 overflow-y-auto p-6 space-y-4">            {/* Error Message */}

          {loading ? (            {error && (

            <div className="flex justify-center items-center py-12">              <div className="text-red-600 text-sm flex items-center gap-1">

              <LoadingSpinner />                <AlertTriangle className="w-4 h-4" />

            </div>                <span>{error}</span>

          ) : comments.length === 0 ? (              </div>

            <div className="text-center py-12">            )}

              <MessageCircle className="w-16 h-16 text-gray-300 mx-auto mb-4" />          </div>

              <p className="text-gray-500">No comments yet. Start the conversation!</p>          <button

            </div>            onClick={onClose}

          ) : (            className="text-gray-400 hover:text-gray-500"

            comments.map(comment => (          >

              <div            <X className="w-5 h-5" />

                key={comment.id}          </button>

                className={`p-4 rounded-xl border-2 animate-fadeIn ${        </div>

                  comment.type === 'blocker'

                    ? 'bg-gradient-to-r from-red-50 via-red-100 to-red-50 border-red-300 shadow-lg shadow-red-200/50'        {/* Comments List */}

                    : comment.mentions.includes(currentUser.id)        <div className="flex-1 overflow-y-auto p-6 space-y-4">

                    ? 'bg-gradient-to-r from-indigo-50 via-indigo-100 to-indigo-50 border-indigo-300 shadow-md'          {comments.length === 0 ? (

                    : 'bg-gray-50 border-gray-200'            <div className="text-center py-12">

                }`}              <MessageCircle className="w-16 h-16 text-gray-300 mx-auto mb-4" />

              >              <p className="text-gray-500">No comments yet. Start the conversation!</p>

                <div className="flex items-start justify-between mb-2">            </div>

                  <div className="flex items-center">          ) : (

                    <div className="w-10 h-10 rounded-full bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center text-white font-bold mr-3">            comments.map(comment => (

                      {comment.authorName.charAt(0)}              <div

                    </div>                key={comment.id}

                    <div>                className={`p-4 rounded-xl border-2 animate-fadeIn ${

                      <p className="font-semibold text-gray-900">{comment.authorName}</p>                  comment.type === 'blocker'

                      <div className="flex items-center text-xs text-gray-500">                    ? 'bg-gradient-to-r from-red-50 via-red-100 to-red-50 border-red-300 shadow-lg shadow-red-200/50'

                        <Clock className="w-3 h-3 mr-1" />                    : comment.mentions.includes(currentUser.id)

                        {formatDistanceToNow(new Date(comment.createdAt), { addSuffix: true })}                    ? 'bg-gradient-to-r from-indigo-50 via-indigo-100 to-indigo-50 border-indigo-300 shadow-md'

                        {comment.edited && <span className="ml-2 italic">(edited)</span>}                    : 'bg-gray-50 border-gray-200'

                      </div>                }`}

                    </div>              >

                  </div>                <div className="flex items-start justify-between mb-2">

                  {comment.authorId === currentUser.id && (                  <div className="flex items-center">

                    <div className="flex items-center gap-2">                    <div className="w-10 h-10 rounded-full bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center text-white font-bold mr-3">

                      <button                      {comment.authorName.charAt(0)}

                        onClick={() => {                    </div>

                          const newText = prompt('Edit comment:', comment.text);                    <div>

                          if (newText && newText !== comment.text) {                      <p className="font-semibold text-gray-900">{comment.authorName}</p>

                            updateComment(comment.id, { text: newText });                      <div className="flex items-center text-xs text-gray-500">

                          }                        <Clock className="w-3 h-3 mr-1" />

                        }}                        {new Date(comment.createdAt).toLocaleString()}

                        className="p-1 text-gray-500 hover:text-indigo-600 rounded transition-colors"                        {comment.edited && <span className="ml-2 italic">(edited)</span>}

                      >                      </div>

                        <Edit2 className="w-4 h-4" />                    </div>

                      </button>                  </div>

                      <button                  {comment.type === 'blocker' && (

                        onClick={() => {                    <span className="flex items-center px-3 py-1 bg-gradient-to-r from-red-600 to-red-700 text-white text-xs font-bold rounded-full shadow-lg animate-pulse">

                          if (window.confirm('Are you sure you want to delete this comment?')) {                      <AlertTriangle className="w-3 h-3 mr-1" />

                            deleteComment(comment.id);                      BLOCKER

                          }                    </span>

                        }}                  )}

                        className="p-1 text-gray-500 hover:text-red-600 rounded transition-colors"                </div>

                      >                <div className="ml-13 text-gray-700 whitespace-pre-wrap">

                        <Trash2 className="w-4 h-4" />                  {renderCommentText(comment.text)}

                      </button>                </div>

                    </div>                {comment.type === 'blocker' && comment.metadata.blockerType && (

                  )}                  <div className="ml-13 mt-2">

                  {comment.type === 'blocker' && (                    <span className="inline-flex items-center px-3 py-1 bg-gradient-to-r from-red-700 to-red-800 text-white text-xs font-bold rounded-lg shadow-md">

                    <span className="flex items-center px-3 py-1 bg-gradient-to-r from-red-600 to-red-700 text-white text-xs font-bold rounded-full shadow-lg animate-pulse">                      Type: {comment.metadata.blockerType.replace('_', ' ').toUpperCase()}

                      <AlertTriangle className="w-3 h-3 mr-1" />                    </span>

                      BLOCKER                  </div>

                    </span>                )}

                  )}              </div>

                </div>            ))

                <div className="ml-13 text-gray-700 whitespace-pre-wrap">          )}

                  {renderCommentText(comment.text)}        </div>

                </div>

                {comment.type === 'blocker' && comment.metadata.blockerType && (        {/* Input Area */}

                  <div className="ml-13 mt-2">        <div className="p-6 border-t border-gray-200 bg-gray-50">

                    <span className="inline-flex items-center px-3 py-1 bg-gradient-to-r from-red-700 to-red-800 text-white text-xs font-bold rounded-lg shadow-md">          {/* Blocker Toggle */}

                      Type: {comment.metadata.blockerType.replace('_', ' ').toUpperCase()}          <div className="mb-4 flex items-center justify-between">

                    </span>            <label className="flex items-center cursor-pointer">

                  </div>              <input

                )}                type="checkbox"

                <Reactions                checked={isBlocker}

                  taskId={task.id}                onChange={(e) => setIsBlocker(e.target.checked)}

                  commentId={comment.id}                className="w-5 h-5 text-red-600 border-gray-300 rounded focus:ring-red-500"

                  reactions={comment.reactions || []}              />

                />              <span className="ml-3 text-sm font-medium text-gray-700 flex items-center">

              </div>                <AlertTriangle className="w-4 h-4 mr-1 text-red-600" />

            ))                Report as Blocker

          )}              </span>

        </div>            </label>



        {/* Typing Indicator */}            {isBlocker && (

        {typingUsers.length > 0 && (              <select

          <div className="px-6 py-2 border-t border-gray-200">                value={blockerType}

            <TypingIndicator userIds={typingUsers} />                onChange={(e) => setBlockerType(e.target.value)}

          </div>                className="px-3 py-1 border border-red-300 rounded-lg text-sm focus:ring-2 focus:ring-red-500"

        )}              >

                <option value="dependency">Dependency Issue</option>

        {/* Input Area */}                <option value="technical">Technical Problem</option>

        <div className="p-6 border-t border-gray-200 bg-gray-50">                <option value="resource">Resource Unavailable</option>

          {/* Blocker Toggle */}                <option value="clarification">Need Clarification</option>

          <div className="mb-4 flex items-center justify-between">                <option value="external">External Blocker</option>

            <label className="flex items-center cursor-pointer">                <option value="other">Other</option>

              <input              </select>

                type="checkbox"            )}

                checked={isBlocker}          </div>

                onChange={(e) => setIsBlocker(e.target.checked)}

                className="w-5 h-5 text-red-600 border-gray-300 rounded focus:ring-red-500"          {/* Mention Suggestions */}

              />          {showMentions && suggestions.length > 0 && (

              <span className="ml-3 text-sm font-medium text-gray-700 flex items-center">            <div className="mb-2 bg-white border border-gray-300 rounded-lg shadow-lg max-h-40 overflow-y-auto">

                <AlertTriangle className="w-4 h-4 mr-1 text-red-600" />              {suggestions.map(user => (

                Report as Blocker                <button

              </span>                  key={user.id}

            </label>                  onClick={() => insertMention(user)}

                  className="w-full px-4 py-2 text-left hover:bg-indigo-50 flex items-center transition"

            {isBlocker && (                >

              <select                  <div className="w-8 h-8 rounded-full bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center text-white font-bold text-sm mr-3">

                value={blockerType}                    {user.name.charAt(0)}

                onChange={(e) => setBlockerType(e.target.value)}                  </div>

                className="px-3 py-1 border border-red-300 rounded-lg text-sm focus:ring-2 focus:ring-red-500"                  <div>

              >                    <p className="text-sm font-medium text-gray-900">{user.name}</p>

                <option value="dependency">Dependency Issue</option>                    <p className="text-xs text-gray-500">{user.email}</p>

                <option value="technical">Technical Problem</option>                  </div>

                <option value="resource">Resource Unavailable</option>                </button>

                <option value="clarification">Need Clarification</option>              ))}

                <option value="external">External Blocker</option>            </div>

                <option value="other">Other</option>          )}

              </select>

            )}          {/* Textarea */}

          </div>          <div className="relative">

            <textarea

          {/* Mention Suggestions */}              ref={textareaRef}

          {showMentions && (              value={commentText}

            <div className="mb-2 bg-white border border-gray-300 rounded-lg shadow-lg max-h-40 overflow-y-auto">              onChange={handleTextChange}

              {getMentionSuggestions().map(user => (              placeholder="Type your comment... Use @ to mention someone"

                <button              className={`w-full px-4 py-3 border-2 rounded-xl resize-none focus:ring-2 focus:outline-none ${

                  key={user.id}                isBlocker

                  onClick={() => insertMention(user)}                  ? 'border-red-300 focus:ring-red-500'

                  className="w-full px-4 py-2 text-left hover:bg-indigo-50 flex items-center transition"                  : 'border-gray-300 focus:ring-indigo-500'

                >              }`}

                  <div className="w-8 h-8 rounded-full bg-gradient-to-br from-indigo-400 to-purple-500 flex items-center justify-center text-white font-bold text-sm mr-3">              rows={4}

                    {user.name.charAt(0)}            />

                  </div>            <div className="absolute bottom-3 right-3 text-xs text-gray-400">

                  <div>              Tip: Type @ to mention someone

                    <p className="text-sm font-medium text-gray-900">{user.name}</p>            </div>

                    <p className="text-xs text-gray-500">{user.email}</p>          </div>

                  </div>

                </button>          {/* Action Buttons */}

              ))}          <div className="flex items-center justify-between mt-4">

            </div>            <button

          )}              onClick={() => {

                const atPosition = commentText.length;

          {/* Comment Input */}                setCommentText(commentText + '@');

          <div className="relative">                setCursorPosition(atPosition + 1);

            <textarea                setShowMentions(true);

              ref={textareaRef}                textareaRef.current?.focus();

              value={commentText}              }}

              onChange={handleTextChange}              className="flex items-center px-4 py-2 text-gray-600 hover:bg-gray-200 rounded-lg transition"

              onKeyDown={(e) => {            >

                if (e.key === 'Enter' && !e.shiftKey && !showMentions) {              <AtSign className="w-4 h-4 mr-2" />

                  e.preventDefault();              Mention

                  handleSubmit();            </button>

                }

              }}            <div className="flex gap-3">

              placeholder="Type your comment... Use @ to mention someone"              <button

              className={`w-full px-4 py-3 border-2 rounded-xl resize-none focus:ring-2 focus:outline-none ${                onClick={onClose}

                isBlocker                className="px-6 py-2 border border-gray-300 text-gray-700 hover:bg-gray-100 rounded-xl transition font-medium"

                  ? 'border-red-300 focus:ring-red-500'              >

                  : 'border-gray-300 focus:ring-indigo-500'                Cancel

              }`}              </button>

              rows={4}              <button

            />                onClick={handleSubmit}

            <div className="absolute bottom-3 right-3 text-xs text-gray-400">                disabled={!commentText.trim()}

              Tip: Press Enter to send, Shift + Enter for new line                className={`flex items-center px-6 py-2 rounded-xl transition font-medium ${

            </div>                  isBlocker

          </div>                    ? 'bg-red-600 hover:bg-red-700 text-white disabled:bg-gray-300'

                    : 'bg-indigo-600 hover:bg-indigo-700 text-white disabled:bg-gray-300'

          {/* Action Buttons */}                } disabled:cursor-not-allowed`}

          <div className="flex items-center justify-between mt-4">              >

            <button                <Send className="w-4 h-4 mr-2" />

              onClick={() => {                {isBlocker ? 'Report Blocker' : 'Send Comment'}

                const atPosition = commentText.length;              </button>

                setCommentText(commentText + '@');            </div>

                setCursorPosition(atPosition + 1);          </div>

                setShowMentions(true);        </div>

                textareaRef.current?.focus();      </div>

              }}    </div>

              className="flex items-center px-4 py-2 text-gray-600 hover:bg-gray-200 rounded-lg transition"  );

            >};

              <AtSign className="w-4 h-4 mr-2" />

              Mentionexport default TaskCommentsModal;

            </button>

            <div className="flex gap-3">
              <button
                onClick={onClose}
                className="px-6 py-2 border border-gray-300 text-gray-700 hover:bg-gray-100 rounded-xl transition font-medium"
              >
                Cancel
              </button>
              <button
                onClick={handleSubmit}
                disabled={!commentText.trim()}
                className={`flex items-center px-6 py-2 rounded-xl transition font-medium ${
                  isBlocker
                    ? 'bg-red-600 hover:bg-red-700 text-white disabled:bg-gray-300'
                    : 'bg-indigo-600 hover:bg-indigo-700 text-white disabled:bg-gray-300'
                } disabled:cursor-not-allowed`}
              >
                <Send className="w-4 h-4 mr-2" />
                {isBlocker ? 'Report Blocker' : 'Send Comment'}
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};